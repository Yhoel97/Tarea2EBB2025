# Controlador Personalizado para Robot e-puck en Webots

from controller import Robot
import math
import datetime

# ===== CONFIGURACI√ìN DEL CONTROLADOR =====
TIME_STEP = 64               # Intervalo de simulaci√≥n en milisegundos
MAX_SPEED = 6.28             # Velocidad m√°xima del motor para el e-puck

# ===== INICIALIZACI√ìN DEL ROBOT Y DISPOSITIVOS =====
robot = Robot()  # Crear instancia del robot e-puck

# --- Inicializar sensores de proximidad (ps0 a ps7) ---
prox_sensors = []
for i in range(8):
    sensor = robot.getDevice(f'ps{i}')
    sensor.enable(TIME_STEP)
    prox_sensors.append(sensor)

# --- Inicializar sensores adicionales con manejo de errores ---
try:
    light_sensor = robot.getDevice("ls0")
    light_sensor.enable(TIME_STEP)
except:
    light_sensor = None

try:
    gyro = robot.getDevice("gyro")
    gyro.enable(TIME_STEP)
except:
    gyro = None

try:
    acc = robot.getDevice("accelerometer")
    acc.enable(TIME_STEP)
except:
    acc = None

try:
    camera = robot.getDevice("camera")
    camera.enable(TIME_STEP)
except:
    camera = None

# --- Configurar motores de las ruedas en modo velocidad continua ---
left_motor = robot.getDevice('left wheel motor')
right_motor = robot.getDevice('right wheel motor')
left_motor.setPosition(float('inf'))
right_motor.setPosition(float('inf'))
left_motor.setVelocity(0.0)
right_motor.setVelocity(0.0)

# --- Inicializar LEDs (opcional) ---
leds = []
for i in range(10):
    try:
        led = robot.getDevice(f'led{i}')
        leds.append(led)
    except:
        pass  # Ignorar si el LED no existe

# ===== FUNCI√ìN PARA CONTROL DE LEDS POR ESTADO =====
def set_led_state(state: str):
    """Enciende los LEDs con un color representando el estado del robot."""
    colors = {
        'go': (1, 0, 0),       # Verde
        'turning': (0, 0, 1),  # Azul
        'obstacle': (0, 1, 0), # Rojo
        'goal': (1, 1, 0),     # Amarillo
        'stuck': (1, 0, 1),    # Violeta
    }
    r, g, b = colors.get(state, (0, 0, 0))
    for led in leds:
        led.set(r + g * 2 + b * 4)  # Codificaci√≥n RGB de Webots

# ===== LECTURA DE UN SENSOR DE PROXIMIDAD =====
def read_proximity(index):
    return prox_sensors[index].getValue()

# ===== M√âTRICAS DEL SIMULADOR =====
start_time = robot.getTime()
distance = 0.0
collisions = 0
goal_reached = False

# ===== L√ìGICA DE NAVEGACI√ìN DEL ROBOT =====
def navigate():
    global collisions, goal_reached

    # Leer sensores frontales y lateral derecho
    front_left = read_proximity(0)
    front_right = read_proximity(7)
    side_right = read_proximity(2)

    # Evaluar obst√°culos
    obstacle_ahead = front_left > 80 or front_right > 80
    right_clear = side_right < 60

    # Detecci√≥n de colisi√≥n frontal fuerte
    if front_left > 100 and front_right > 100:
        collisions += 1
        set_led_state('obstacle')
        left_motor.setVelocity(-0.5 * MAX_SPEED)
        right_motor.setVelocity(-0.5 * MAX_SPEED)
        for _ in range(5):
            robot.step(TIME_STEP)  # Retrocede por un momento
        return

    # Comportamientos de evasi√≥n
    if obstacle_ahead:
        set_led_state('turning')
        left_motor.setVelocity(0.4 * MAX_SPEED)
        right_motor.setVelocity(-0.4 * MAX_SPEED)
    elif right_clear:
        set_led_state('turning')
        left_motor.setVelocity(0.6 * MAX_SPEED)
        right_motor.setVelocity(0.2 * MAX_SPEED)
    else:
        set_led_state('go')
        left_motor.setVelocity(0.5 * MAX_SPEED)
        right_motor.setVelocity(0.5 * MAX_SPEED)

    # Detecci√≥n de luz intensa como se√±al de llegada
    if light_sensor and light_sensor.getValue() > 600:
        set_led_state('goal')
        goal_reached = True

# ===== BUCLE PRINCIPAL DE LA SIMULACI√ìN =====
print("‚úÖ Controlador personalizado del e-puck iniciado.")
while robot.step(TIME_STEP) != -1 and not goal_reached:
    navigate()

    # Calcular distancia estimada recorrida
    v_left = left_motor.getVelocity()
    v_right = right_motor.getVelocity()
    v_avg = (v_left + v_right) / 2
    distance += abs(v_avg * (TIME_STEP / 1000))

# ===== RESULTADOS AL FINALIZAR LA SIMULACI√ìN =====
end_time = robot.getTime()
total_time = end_time - start_time

print("\nüìä RESULTADOS DE LA SIMULACI√ìN")
print(f"‚è± Tiempo total     : {total_time:.2f} segundos")
print(f"üìè Distancia estimada : {distance:.2f} unidades")
print(f"üí• Colisiones       : {collisions}")
print(f"üéØ Meta alcanzada   : {'S√≠' if goal_reached else 'No'}")

# ===== GUARDAR RESULTADOS EN ARCHIVO =====
fecha = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
try:
    with open(f"resultados_navegacion_{fecha}.txt", "w") as file:
        file.write("RESULTADOS DE LA SIMULACI√ìN\n")
        file.write(f"Tiempo total     : {total_time:.2f} s\n")
        file.write(f"Distancia aprox. : {distance:.2f} unidades\n")
        file.write(f"Colisiones       : {collisions}\n")
        file.write(f"Meta alcanzada   : {'S√≠' if goal_reached else 'No'}\n")
    print("üìù Resultados guardados exitosamente.")
except:
    print("‚ö†Ô∏è No se pudo guardar el archivo de resultados.")
